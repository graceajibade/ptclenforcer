package ptclenforcer

import (
	"os"
	"fmt"
	"strconv"
	"strings"
)

func getInterfaceName(MethodName string) string {
	return MethodName + "Resp"
}

func pkgQualifier(t string) (pkg, name string) {
    if i := strings.LastIndex(t, "."); i >= 0 {
        return t[:i], t[i+1:]
    }
    return "", t
}


func splitParam(s string) (name, typ string) {
    s = strings.TrimSpace(s)
    if s == "" { return "", "" }

    parts := strings.Fields(s)
    switch len(parts) {
    case 1:
        // unnamed param like "any" or "json.Token"
        return "", parts[0]
    default:
        // "v any" or "v json.Token"
        return parts[0], strings.Join(parts[1:], " ")
    }
}

func GenerateTSAPI(fsm FSM, rawLogic RawTransition, pkg, protocol string) (API, error) {
	var api API

	if _, ok := fsm.States[fsm.S0]; !ok {
		fsm.States[fsm.S0] = struct{}{}
	}
	if _, ok := fsm.States[fsm.F]; !ok {
		fsm.States[fsm.F] = struct{}{}
	}

	for state := range fsm.States {
		td := TDStruct{
			Name: string(state),
			FieldsList: []FD{
				{"Prtcl", fmt.Sprintf("*%s.%s", pkg, protocol)},
			},
		}
		api.Typedefs = append(api.Typedefs, td)
	}

	for statePair, toList := range fsm.D {
		fromStruct := string(statePair.State)
		MethodName := string(statePair.Label)
		logic := rawLogic[statePair]

		var inputs, outputs []string
		outputs = append(outputs, logic.Outputs...)
		inputs = append(inputs, logic.Inputs...)
		rawMethodName := string(logic.Name)

		var returnList []Returns
		if len(toList) == 1 {
			r := Returns{
				State: string(toList[0].TransitionState),
			}
			returnList = append(returnList, r)
		} else {
			for _, state := range toList {
				r := Returns{
					ItfName: getInterfaceName(MethodName),
					Outcome: state.Outcome,
					State:   string(state.TransitionState),
				}
				returnList = append(returnList, r)
			}
		}

		api.Methoddefs = append(api.Methoddefs, MD{
			Receiver: fromStruct,
			Name:     MethodName,
			RawName:  rawMethodName,
			Inputs:   inputs,
			Outputs:  outputs,
			Returns:  returnList,
		})
	}

	api.IFStates = IFD{
		IState: fsm.S0,
		FState: fsm.F,
	}

	return api, nil
}

func GenerateTSString(apiStruct API, pkg string) (string, error) {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("package ptclenforcer\n\nimport (\n\t\"%s\"\n) \n\n", pkg))
	sb.WriteString("// Autogenerated Typestate API\n\n")

	for _, td := range apiStruct.Typedefs {
		sb.WriteString(fmt.Sprintf("type %s struct {\n", td.TypeName()))
		for _, field := range td.Fields() {
			sb.WriteString(fmt.Sprintf("\t%s %s\n", field.fieldName, field.fieldType))
		}
		sb.WriteString("\tfinalState *bool\n")
		sb.WriteString("\tused bool\n")
		sb.WriteString("}\n\n")
	}

	// Insert FinalStateChecker struct
	sb.WriteString(fmt.Sprintf("type %sChecker struct {\n\tfinalState *bool\n}\n\n", apiStruct.IFStates.FState))
	sb.WriteString(fmt.Sprintf("func (f *%sChecker) FinalizeChecker() func() {\n", apiStruct.IFStates.FState))
	sb.WriteString("\treturn func() {\n")
	sb.WriteString("\t\tif f.finalState == nil || !*f.finalState {\n")
	sb.WriteString("\t\t\tpanic(\"Final state was not reached\")\n")
	sb.WriteString("\t\t}\n\t}\n")
	sb.WriteString("}\n\n")

	interfaceMethods := map[string][]string{}
	for _, md := range apiStruct.Methoddefs {
		for _, itfaces := range md.Returns {
			if itfaces.ItfName != "" {
				interfaceMethods[itfaces.ItfName] = append(interfaceMethods[itfaces.ItfName], itfaces.State)
			}
		}
	}

	for iface, methods := range interfaceMethods {
		sb.WriteString(fmt.Sprintf("type %s interface {\n\t%s()\n}\n\n", iface, iface))
		for _, method := range methods {
			sb.WriteString(fmt.Sprintf("func (x %s) %s() {\n}\n\n", method, iface))
		}
	}

	// Constructor
	var protocolType string
	startStruct := apiStruct.IFStates.IState

	for _, td := range apiStruct.Typedefs {
		if td.TypeName() == string(startStruct) {
			for _, field := range td.Fields() {
				if field.fieldName == "Prtcl" {
					protocolType = field.fieldType
					break
				}
			}
			break
		}
	}

	if protocolType != "" {
		protocolPkg, protocolName := pkgQualifier(protocolType)

		sb.WriteString(fmt.Sprintf("func New%s(prtcl ...%s.%s) (*%s, *%sChecker) {\n", startStruct, protocolPkg, protocolName, startStruct, apiStruct.IFStates.FState))
		sb.WriteString("\tfinalReached := false\n")
		sb.WriteString(fmt.Sprintf("\tchecker := &%sChecker{finalState: &finalReached}\n", apiStruct.IFStates.FState))
		sb.WriteString(fmt.Sprintf("\tvar p %s.%s\n", protocolPkg, protocolName))
		sb.WriteString("\tif len(prtcl) > 0 && prtcl[0] != nil {\n")
		sb.WriteString("\t\tp = prtcl[0]\n")
		sb.WriteString("\t} else {\n")
		basePkg := strings.TrimPrefix(protocolPkg, "*")
		sb.WriteString(fmt.Sprintf("\t\tp = &%s.%s{}\n", basePkg, protocolName))
		sb.WriteString("\t}\n")
		sb.WriteString(fmt.Sprintf("\treturn &%s{\n", startStruct))
		sb.WriteString("\t\tPrtcl: p,\n")
		sb.WriteString("\t\tfinalState: &finalReached,\n")
		sb.WriteString("\t\tused: false,\n")
		sb.WriteString("\t}, checker\n")
		sb.WriteString("}\n\n")
	}

	for _, md := range apiStruct.Methoddefs {
		var returnState string
		if len(md.Returns) > 1 {
			returnState = md.Returns[0].ItfName
		} else {
			returnState = md.Returns[0].State
		}

		sb.WriteString(fmt.Sprintf("// %s - %s -> %s\n", md.Receiver, md.Name, returnState))
		sb.WriteString(fmt.Sprintf("func (x *%s) %s(", md.Receiver, md.Name))

		inputs := strings.Join(md.Inputs, ", ")
		var inputValList []string
		for _, item := range md.Inputs {
			name, typ := splitParam(item)
			if strings.HasPrefix(typ, "...") {
				name += "..." // convert `args` to `args...`
			}
			inputValList = append(inputValList, name)
		}
		inputvals := strings.Join(inputValList, ", ")

		var outputValList []string
		for num := range md.Outputs {
			outputValList = append(outputValList, "res"+strconv.Itoa(num))
		}

		var outputs, outputVals, outputValstring string
		if len(md.Outputs) > 0 {
			outputs = ", " + strings.Join(md.Outputs, ", ")
			outputVals = strings.Join(outputValList, ", ")
			outputValstring = ", " + strings.Join(outputValList, ", ")
		}

		sb.WriteString(inputs)
		sb.WriteString(fmt.Sprintf(") (%s", returnState))
		if len(md.Outputs) > 0 {
			sb.WriteString(outputs)
		}
		sb.WriteString(") {\n")

		sb.WriteString("\tif x.used {\n")
		sb.WriteString(fmt.Sprintf("\t\tpanic(\"%s has been used\")\n", md.Receiver))
		sb.WriteString("\t}\n")
		sb.WriteString("\tx.used = true\n")

		if len(md.Returns) > 1 {
			sb.WriteString(fmt.Sprintf("\t%s := x.Prtcl.%s(%s)\n", outputVals, md.RawName, inputvals))
			for i := 0; i < len(md.Returns)-1; i++ {
				ret := md.Returns[i]
				sb.WriteString(fmt.Sprintf("\tif %s == %t {\n\t\treturn %s{Prtcl: x.Prtcl, finalState: x.finalState, used: false}%s\n\t}\n",
					outputVals, ret.Outcome, ret.State, outputValstring))
			}
			ret := md.Returns[len(md.Returns)-1]
			sb.WriteString(fmt.Sprintf("\treturn %s{Prtcl: x.Prtcl, finalState: x.finalState, used: false}%s\n", ret.State, outputValstring))
			sb.WriteString("}\n\n")
		} else {
			ret := md.Returns[0]
			setFinal := ""
			if ret.State == string(apiStruct.IFStates.FState) {
				setFinal = "\t*x.finalState = true\n"
			}

			if outputVals == "" {
				sb.WriteString(fmt.Sprintf("\tx.Prtcl.%s(%s)\n", md.RawName, inputvals))
			} else {
				sb.WriteString(fmt.Sprintf("\t%s := x.Prtcl.%s(%s)\n", outputVals, md.RawName, inputvals))
			}
			sb.WriteString(setFinal)
			sb.WriteString(fmt.Sprintf("\treturn %s{Prtcl: x.Prtcl, finalState: x.finalState, used: false}%s\n", ret.State, outputValstring))
			sb.WriteString("}\n\n")
		}
	}

	return sb.String(), nil
}

func GenerateTSFile(apiString, fileName string) error {
	f, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.WriteString(apiString)
	return err
}
