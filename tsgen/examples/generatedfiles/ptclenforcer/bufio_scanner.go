package ptclenforcer

import (
	"bufio"
) 

// Autogenerated Typestate API

type HasLine struct {
	Prtcl *bufio.Scanner
	finalState *bool
	used bool
}

type NoMoreLines struct {
	Prtcl *bufio.Scanner
	finalState *bool
	used bool
}

type ScannerDone struct {
	Prtcl *bufio.Scanner
	finalState *bool
	used bool
}

type StartScan struct {
	Prtcl *bufio.Scanner
	finalState *bool
	used bool
}

type ScannerDoneChecker struct {
	finalState *bool
}

func (f *ScannerDoneChecker) FinalizeChecker() func() {
	return func() {
		if f.finalState == nil || !*f.finalState {
			panic("Final state was not reached")
		}
	}
}

type ScanResp interface {
	ScanResp()
}

func (x HasLine) ScanResp() {
}

func (x NoMoreLines) ScanResp() {
}

func NewStartScan(prtcl ...*bufio.Scanner) (*StartScan, *ScannerDoneChecker) {
	finalReached := false
	checker := &ScannerDoneChecker{finalState: &finalReached}
	var p *bufio.Scanner
	if len(prtcl) > 0 && prtcl[0] != nil {
		p = prtcl[0]
	} else {
		p = &bufio.Scanner{}
	}
	return &StartScan{
		Prtcl: p,
		finalState: &finalReached,
		used: false,
	}, checker
}

// StartScan - Scan -> ScanResp
func (x *StartScan) Scan() (ScanResp, bool) {
	if x.used {
		panic("StartScan has been used")
	}
	x.used = true
	res0 := x.Prtcl.Scan()
	if res0 == true {
		return HasLine{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
	}
	return NoMoreLines{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// HasLine - Text -> StartScan
func (x *HasLine) Text() (StartScan, string) {
	if x.used {
		panic("HasLine has been used")
	}
	x.used = true
	res0 := x.Prtcl.Text()
	return StartScan{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// NoMoreLines - Close -> ScannerDone
func (x *NoMoreLines) Close() (ScannerDone, error) {
	if x.used {
		panic("NoMoreLines has been used")
	}
	x.used = true
	res0 := x.Prtcl.Err()
	*x.finalState = true
	return ScannerDone{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

