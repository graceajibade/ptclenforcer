package ptclenforcer

import (
	"encoding/json"
) 

// Autogenerated Typestate API

type Check struct {
	Prtcl *json.Decoder
	finalState *bool
	used bool
}

type DecoderDone struct {
	Prtcl *json.Decoder
	finalState *bool
	used bool
}

type NoMoreData struct {
	Prtcl *json.Decoder
	finalState *bool
	used bool
}

type StartDecode struct {
	Prtcl *json.Decoder
	finalState *bool
	used bool
}

type DecoderDoneChecker struct {
	finalState *bool
}

func (f *DecoderDoneChecker) FinalizeChecker() func() {
	return func() {
		if f.finalState == nil || !*f.finalState {
			panic("Final state was not reached")
		}
	}
}

type MoreResp interface {
	MoreResp()
}

func (x StartDecode) MoreResp() {
}

func (x NoMoreData) MoreResp() {
}

func NewCheck(prtcl ...*json.Decoder) (*Check, *DecoderDoneChecker) {
	finalReached := false
	checker := &DecoderDoneChecker{finalState: &finalReached}
	var p *json.Decoder
	if len(prtcl) > 0 && prtcl[0] != nil {
		p = prtcl[0]
	} else {
		p = &json.Decoder{}
	}
	return &Check{
		Prtcl: p,
		finalState: &finalReached,
		used: false,
	}, checker
}

// Check - More -> MoreResp
func (x *Check) More() (MoreResp, bool) {
	if x.used {
		panic("Check has been used")
	}
	x.used = true
	res0 := x.Prtcl.More()
	if res0 == true {
		return StartDecode{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
	}
	return NoMoreData{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// StartDecode - Decode -> Check
func (x *StartDecode) Decode(v any) (Check, error) {
	if x.used {
		panic("StartDecode has been used")
	}
	x.used = true
	res0 := x.Prtcl.Decode(v)
	return Check{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// NoMoreData - Close -> DecoderDone
func (x *NoMoreData) Close() (DecoderDone, json.Token) {
	if x.used {
		panic("NoMoreData has been used")
	}
	x.used = true
	res0 := x.Prtcl.Buffered()
	*x.finalState = true
	return DecoderDone{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

