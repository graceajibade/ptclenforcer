package ptclenforcer

import (
	"os"
) 

// Autogenerated Typestate API

type Written struct {
	Prtcl *os.File
	finalState *bool
	used bool
}

type Read struct {
	Prtcl *os.File
	finalState *bool
	used bool
}

type Opened struct {
	Prtcl *os.File
	finalState *bool
	used bool
}

type Closed struct {
	Prtcl *os.File
	finalState *bool
	used bool
}

type ClosedChecker struct {
	finalState *bool
}

func (f *ClosedChecker) FinalizeChecker() func() {
	return func() {
		if f.finalState == nil || !*f.finalState {
			panic("Final state was not reached")
		}
	}
}

func NewOpened(prtcl ...*os.File) (*Opened, *ClosedChecker) {
	finalReached := false
	checker := &ClosedChecker{finalState: &finalReached}
	var p *os.File
	if len(prtcl) > 0 && prtcl[0] != nil {
		p = prtcl[0]
	} else {
		p = &os.File{}
	}
	return &Opened{
		Prtcl: p,
		finalState: &finalReached,
		used: false,
	}, checker
}

// Opened - Write -> Written
func (x *Opened) Write(data []byte) (Written, int, error) {
	if x.used {
		panic("Opened has been used")
	}
	x.used = true
	res0, res1 := x.Prtcl.Write(data)
	return Written{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0, res1
}

// Opened - Read -> Read
func (x *Opened) Read(buf []byte) (Read, int, error) {
	if x.used {
		panic("Opened has been used")
	}
	x.used = true
	res0, res1 := x.Prtcl.Read(buf)
	return Read{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0, res1
}

// Written - Close -> Closed
func (x *Written) Close() (Closed, error) {
	if x.used {
		panic("Written has been used")
	}
	x.used = true
	res0 := x.Prtcl.Close()
	*x.finalState = true
	return Closed{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// Read - Close -> Closed
func (x *Read) Close() (Closed, error) {
	if x.used {
		panic("Read has been used")
	}
	x.used = true
	res0 := x.Prtcl.Close()
	*x.finalState = true
	return Closed{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

