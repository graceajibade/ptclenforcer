package ptclenforcer

import (
	"school/project/simplelib"
) 

// Autogenerated Typestate API

type S04 struct {
	Prtcl *simplelib.SimpleStruct
	finalState *bool
	used bool
}

type S14 struct {
	Prtcl *simplelib.SimpleStruct
	finalState *bool
	used bool
}

type S41 struct {
	Prtcl *simplelib.SimpleStruct
	finalState *bool
	used bool
}

type E04 struct {
	Prtcl *simplelib.SimpleStruct
	finalState *bool
	used bool
}

type E04Checker struct {
	finalState *bool
}

func (f *E04Checker) FinalizeChecker() func() {
	return func() {
		if f.finalState == nil || !*f.finalState {
			panic("Final state was not reached")
		}
	}
}

func NewS04(prtcl ...*simplelib.SimpleStruct) (*S04, *E04Checker) {
	finalReached := false
	checker := &E04Checker{finalState: &finalReached}
	var p *simplelib.SimpleStruct
	if len(prtcl) > 0 && prtcl[0] != nil {
		p = prtcl[0]
	} else {
		p = &simplelib.SimpleStruct{}
	}
	return &S04{
		Prtcl: p,
		finalState: &finalReached,
		used: false,
	}, checker
}

// S14 - M41 -> E04
func (x *S14) M41() (E04, string) {
	if x.used {
		panic("S14 has been used")
	}
	x.used = true
	res0 := x.Prtcl.M2()
	*x.finalState = true
	return E04{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// S04 - M41 -> S41
func (x *S04) M41() (S41, string) {
	if x.used {
		panic("S04 has been used")
	}
	x.used = true
	res0 := x.Prtcl.M2()
	return S41{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// S41 - M14 -> E04
func (x *S41) M14() (E04, string) {
	if x.used {
		panic("S41 has been used")
	}
	x.used = true
	res0 := x.Prtcl.M1()
	*x.finalState = true
	return E04{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// S04 - M14 -> S14
func (x *S04) M14() (S14, string) {
	if x.used {
		panic("S04 has been used")
	}
	x.used = true
	res0 := x.Prtcl.M1()
	return S14{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

