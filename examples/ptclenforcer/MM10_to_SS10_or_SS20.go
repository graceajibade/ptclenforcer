package ptclenforcer

import (
	"school/project/simplelib"
) 

// Autogenerated Typestate API

type SS10 struct {
	Prtcl *simplelib.SimpleStructTwo
	finalState *bool
	used bool
}

type SS20 struct {
	Prtcl *simplelib.SimpleStructTwo
	finalState *bool
	used bool
}

type SS00 struct {
	Prtcl *simplelib.SimpleStructTwo
	finalState *bool
	used bool
}

type EE00 struct {
	Prtcl *simplelib.SimpleStructTwo
	finalState *bool
	used bool
}

type EE00Checker struct {
	finalState *bool
}

func (f *EE00Checker) FinalizeChecker() func() {
	return func() {
		if f.finalState == nil || !*f.finalState {
			panic("Final state was not reached")
		}
	}
}

type MM10Resp interface {
	MM10Resp()
}

func (x SS10) MM10Resp() {
}

func (x SS20) MM10Resp() {
}

func NewSS00(prtcl ...*simplelib.SimpleStructTwo) (*SS00, *EE00Checker) {
	finalReached := false
	checker := &EE00Checker{finalState: &finalReached}
	var p *simplelib.SimpleStructTwo
	if len(prtcl) > 0 && prtcl[0] != nil {
		p = prtcl[0]
	} else {
		p = &simplelib.SimpleStructTwo{}
	}
	return &SS00{
		Prtcl: p,
		finalState: &finalReached,
		used: false,
	}, checker
}

// SS00 - MM10 -> MM10Resp
func (x *SS00) MM10(choice int) (MM10Resp, bool) {
	if x.used {
		panic("SS00 has been used")
	}
	x.used = true
	res0 := x.Prtcl.MM1(choice)
	if res0 == true {
		return SS10{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
	}
	return SS20{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// SS10 - MM20 -> SS00
func (x *SS10) MM20() (SS00, string) {
	if x.used {
		panic("SS10 has been used")
	}
	x.used = true
	res0 := x.Prtcl.MM2()
	return SS00{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

// SS20 - MM30 -> EE00
func (x *SS20) MM30() (EE00, string) {
	if x.used {
		panic("SS20 has been used")
	}
	x.used = true
	res0 := x.Prtcl.MM3()
	*x.finalState = true
	return EE00{Prtcl: x.Prtcl, finalState: x.finalState, used: false}, res0
}

